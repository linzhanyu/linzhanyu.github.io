---
layout: post
title: Unity 优化之奇技淫巧
categories: [game, unity3d, optimization]
tags: [unity3d, optimization]
fullview: false
comments: true
---

自从 Unity3d **免费** 以来，非常多的公司个人搭上这只贼船。由于易上手，太多的项目粗枝滥造，不槛入目。经过几个项目的历练，我们来总结一下Unity3D使用过程中应该注意的一些地方吧。希望能起到点作用。

## CPU
做游戏 80% 的代码都是跑在 CPU 上的，除了游戏中的逻辑代码需要在CPU做相关计算之外，还有很多图形相关的计算是由CPU驱动的。

所以写每一个函数的时候都应该走脑子，一个不留神这些代码就造成我们背锅，加班的罪魁祸首。

### Script
Unity3d 为我们提供了一种非常简捷的方式 **MonoBehaviour** 来让大家方便地实现自己的功能,但是有不少的开发者认为只要把功能做在 MonoBehaviour 中，再挂到需要的 GameObject 上就是**组件式编程**了，殊不知这样并不是组件式编程，少量的挂接并不会造成太大的问题，但当这些 GameObject 被代码大量的实例化以后，情况就不是那么乐观了。

好，为什么会有问题捏？

Unity3d 是C++写成的，我们在使用 Unity3d 时，所写的代码是 C# 写成的。C++ 是自己分配并释放内存 我们称其为 **Native堆**，而C#是将所有的动态内存对象存放在一个称做**托管堆**的地方。托管堆是 CLR 划出的地址空间，并且由CLR做垃圾回收。C# 做为一种 C++ 的脚本语言，当有 MonoBehaviour 挂在 GameObject 上时C++需要为这些脚本准备相应的Native堆，并为它们准备执行序列，轮流调用。在C++调用C#的时候需要做一些准备工作，而这些准备工作是有开销的。所以这种调用远比 C# 直接调用 C# 要慢得多，而且内存占用也大的多。

### DrawCall

#### DrawCall 是什么？
OpenGL ES 的函数调用中 glDrawElements 负责将三角形的绘制发送给显卡驱动程序，每一次调用就是一个 DrawCall。这个函数可以一次将非常多的三角形下发。

打个比方说，一个模型有 1000 个三角形组成，如果场景中有10个这样的模型。

>1. 把1000个三角形画10次，得到了场景画面A；
>1. 把10000个三角形画1次，得到了场景画面B；

在精心准备的情况下，这个画面A和画面B是可以相同的。

#### Static Batching

>1. **相同材质**
>2. **不能移动**

唯一的条件使得静态合并更容易使用，当然它是有副作用的。不能移动的原因猜测是由于每个模型的世界坐标的不同，合并后有些矩阵没法分别给单个模型单独设置。就只好把顶点的位置预先计算好，存在一个Vertex Buffer中，就这样带来了顶点内存使用量x2 如果顶点数量太多的时候，这里需要小心。

尽量多的静态批次，DrawCall一定是最大化合并的。因为它很容易获得。

另外在代码中 StaticBatchingUtility.Combine 也可以用来对没有勾Static的节点进行统一合并。


**主要用途** 场景模型

#### Dynamic Batching

>1. **材质相同**
>2. **模型总顶点数<900**
>3. **用法线单个模型顶点数<300**
>4. **用UV0, UV1 或Tangent时单模型顶点数不超<180**
>5. **相同的缩放值**
>6. **没有使用 lightmap**
>7. **Shader 没有使用多 Pass**

只要满足上面的条件，这些模型会被自动 Dynamic Batching 合并 DrawCall

**主要用途** 特效粒子动画

#### Culling

经过精心对 Static batch 和 Dynamic batch 的安排大部分的游戏项目 DrawCall 数已经能够进入到一个可接受的范围。如果依然很高，说明你的项目内容是比较复杂的了。

剔除操作很重要，Unity3d 提供的 Occlusion Culling （遮挡易除）是一个非常有用的功能。

#### LOD

那么第一个问题：什么是 LOD ？

## GPU

### Shader

#### if 到底怎么啦

### Texture

#### Tex2D 的那些事儿


### Bus

## IO

## Mem

### 托管堆

### GC



